\documentclass{ieeetj}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx,color}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
%\hypersetup{hidelinks=true}
\usepackage{algorithm,algorithmic}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\AtBeginDocument{\definecolor{tmlcncolor}{cmyk}{0.93,0.59,0.15,0.02}\definecolor{NavyBlue}{RGB}{0,86,125}}


\newcommand{\encB}[1]{\mathsf{enc}^{\mathrm{B64}}\!\left(#1\right)}
\newcommand{\decB}[1]{\mathsf{dec}^{\mathrm{B64}}\!\left(#1\right)}
\newcommand{\encP}[1]{\mathsf{enc}^{\mathrm{poly}}\!\left(#1\right)}
\newcommand{\decP}[1]{\mathsf{dec}^{\mathrm{poly}}\!\left(#1\right)}

\newcommand{\ser}[1]{\mathsf{ser}^{\mathrm{bin}}\!\left(#1\right)}
\newcommand{\des}[1]{\mathsf{des}^{\mathrm{bin}}\!\left(#1\right)}
\newcommand{\selMinLogN}[1]{\mathsf{selMinLogN}\!\left(#1\right)}
\newcommand{\selParams}[1]{\mathsf{selParams}\!\left(#1\right)}
\newcommand{\genRecords}[1]{\mathsf{genRecords}\!\left(#1\right)}
\newcommand{\feasible}[1]{\mathsf{feasible}\!\left(#1\right)}



\def\OJlogo{\vspace{-4pt}$<$Society logo(s) and publication title will appear here.$>$}
\def\seclogo{\vspace{10pt}$<$Society logo(s) and publication title will appear here.$>$}

\def\authorrefmark#1{\ensuremath{^{\textbf{#1}}}}

\begin{document}
\receiveddate{XX Month, XXXX}
\reviseddate{XX Month, XXXX}
\accepteddate{XX Month, XXXX}
\publisheddate{XX Month, XXXX}
\currentdate{XX Month, XXXX}
\doiinfo{XXXX.2022.1234567}

\markboth{}{Author {et al.}}

\title{Blind Chaincode: Enabling Computational Private Information Retrieval for Query Privacy in Hyperledger Fabric}


\author{First A. Author\authorrefmark{1}, Fellow, IEEE, Second B. Author\authorrefmark{2},\\ and Third C. Author Jr.\authorrefmark{3}, Member, IEEE}
\affil{National Institute of Standards and Technology, Boulder, CO 80305 USA}
\affil{Department of Physics, Colorado State University, Fort Collins, CO 80523 USA}
\affil{Electrical Engineering Department, University of Colorado, Boulder, CO 80309 USA}
\corresp{Corresponding author: First A. Author (email: author@ boulder.nist.gov).}
\authornote{This paragraph of the first footnote will contain support information, including sponsor and financial support acknowledgment. For example, ``This work was supported in part by the U.S. Department of Commerce under Grant 123456.''}


\begin{abstract}
    Permissioned blockchains ensure integrity and auditability of shared data but expose query parameters to endorsing peers during read operations. 
    In Hyperledger Fabric, evaluate calls are executed by peers who observe function arguments and read-sets, creating privacy risks for organizations querying sensitive records. 
    We address this gap by presenting the first practical integration of Computational Private Information Retrieval (CPIR) into Fabric chaincode. 
    Our design encodes the ledger’s key–value table as a plaintext polynomial and allows clients to submit encrypted selection vectors, evaluated under the Brakerski--Gentry--Vaikuntanathan (BGV) homomorphic encryption scheme. 
    Peers return only encrypted responses, preventing index leakage while preserving normal Fabric endorsement and audit flows. 
    We prototype the system with the Lattigo library and benchmark client-side encryption/decryption, peer-side evaluation, ciphertext size, and end-to-end query latency. 
    Results show that single-query latencies remain practical for typical Fabric deployments, while eliminating the privacy leakage of baseline \texttt{GetState} operations. 
    This work demonstrates the feasibility of embedding CPIR directly into permissioned blockchains and provides a foundation for future enhancements such as post-quantum schemes, zero-knowledge proofs, and sublinear retrieval.
\end{abstract}
    

\begin{IEEEkeywords}
    Private Information Retrieval (PIR), Homomorphic Encryption, Hyperledger Fabric, Permissioned Blockchains, Private Reads, Query Privacy.
\end{IEEEkeywords}
    
    

%\IEEEspecialpapernotice{(Invited Paper)}

\maketitle

\section{INTRODUCTION}\label{sec:introduction}

\subsection{MOTIVATION AND CONTRIBUTION}

Permissioned blockchains such as Hyperledger Fabric are widely adopted for tamper-evident and auditable data management across consortiums. 
Their guarantees, however, primarily cover writes. 
In Fabric, the separation of \emph{evaluate} and \emph{submit} makes the read-privacy gap explicit: an evaluate call is a read-only proposal sent to endorsing peers, which execute the chaincode and return results without committing to the ledger. 
Crucially, these peers still observe all function arguments and read-sets. 
Thus, in multi-organization settings, the dominant privacy risk arises not from the immutable ledger, but from endorsing peers who can log or infer sensitive query information.

Private Information Retrieval (PIR)~\cite{ref16_Chor1998Private} addresses this challenge by enabling a client to retrieve an item from a database without revealing which item was requested. 
For a database $D = \{d_0,\dots,d_{n-1}\}$, the client forms a one-hot selection vector $\hat{v}_i$ with a single ``1'' at index $i$. 
By encrypting $\hat{v}_i$ into $c_q = \text{Enc}_{pk}(\hat{v}_i)$ and sending it to the server, the server computes an encrypted response 
$c_r = c_q \cdot D = \text{Enc}_{pk}(d_i)$, 
which decrypts to $d_i$ under the client’s secret key. 
This construction hides the queried index from the server. 
When integrated with Fabric chaincode, PIR prevents endorsing peers from linking queries to specific records, while preserving blockchain auditability for writes.

Figure~\ref{fig1} illustrates this contrast. 
A baseline query call \textit{PublicQueryWithAudit("record012")} explicitly reveals the queried key in the audit log visible to endorsing peers. 
In contrast, our \textit{PIRQueryWithAudit(encQueryB64)} logs only an opaque Base64-encoded selector, preventing the audit trail or the read-set from exposing query intent.

\begin{figure}[!t]
    \centerline{\includegraphics[width=\columnwidth]{figures/diagrams/0_pir.png}}
    \caption{What endorsing peers ``see'' in audit records. 
    Left: baseline \textit{PublicQueryWithAudit} exposes the queried key (\textit{record012}). 
    Right: CPIR-based \textit{PIRQueryWithAudit} exposes only an opaque encrypted selector (\textit{EncQueryB64}), hiding the queried index.\label{fig1}}    
\end{figure}

The main contributions of this work are:
\begin{enumerate}
    \item \textbf{BGV-based CPIR as Fabric chaincode.} We present, to the best of our knowledge, the first fully on-chain implementation of Computational PIR (CPIR) based on the BGV scheme, integrated directly into Hyperledger Fabric chaincode.
    \item \textbf{Evaluate-phase privacy demonstration.} We provide a side-by-side analysis of baseline vs. CPIR queries, showing how endorsing peers’ visibility is reduced to opaque ciphertexts while preserving Fabric’s normal endorsement and audit mechanisms.
    \item \textbf{Prototype and benchmarks.} We implement a working system with the Lattigo library and measure client encryption/decryption, peer evaluation, ciphertext size, and end-to-end query latency, demonstrating practical performance for consortium deployments.
    \item \textbf{Open-Source Release.} To encourage reproducibility and use by other researchers, we open-source the complete CPIR-on-Blockchain system, including chaincode, client, and experimental setup. The repository is available at: \url{https://github.com/artias13/2_2_HLF_CPIR}.
\end{enumerate}

\subsection{LITERATURE REVIEW}

Privacy in permissioned blockchains has been studied from several angles, but query privacy remains underexplored. 

\textbf{Blockchain Privacy Mechanisms.} 
Early efforts have emphasized access control and anonymity. 
Token-based authentication schemes~\cite{huff2021} and access-control contracts~\cite{allouche2020} prevent unauthorized reads or hide participant identities. 
Differential-sharing frameworks~\cite{dunnett2019} allow producers to regulate how much content is revealed. 
While effective at controlling \emph{who} sees data, these mechanisms do not conceal \emph{which} records are queried. 
Queries themselves remain visible to endorsing peers.

\textbf{PIR and FHE Applications.}
A line of work has applied Private Information Retrieval (PIR) or Fully Homomorphic Encryption (FHE) to protect data access. 
Tan et al.~\cite{tan2019} use CPIR to hide vehicular location queries. 
Chakraborty et al.~\cite{chakraborty2020} propose BRON, combining PIR with zero-knowledge proofs for human-resource data. 
Mazmudar et al.~\cite{mazmudar2021} integrate PIR with IPFS for private queries in distributed file sharing, while Hameed et al.~\cite{hameed2022} present DEBPIR, embedding an Oblivious Transfer–based PIR into Fabric smart contracts. 
These works demonstrate the feasibility of PIR in distributed settings but often rely on off-chain servers or specialized cryptographic protocols.

\textbf{On-Chain CPIR Gap.}
Existing solutions for Fabric focus on access restriction (channels, PDC) or enclave-based confidentiality (FPC). 
Recent PIR-based proposals either target off-chain databases or prototype OT-based protocols. 
To our knowledge, no prior system has directly integrated a lattice-based CPIR scheme into Fabric chaincode. 
Our work closes this gap by embedding a BGV-based PIR workflow directly in Fabric’s evaluate path, ensuring that endorsing peers cannot infer queried indices while preserving normal endorsement and auditability.

\subsection{ORGANIZATION}

The remainder of this paper is organized as follows: Section~II surveys related work on PIR and blockchain privacy. Section~III presents the system model and threat assumptions. Section~IV details the design and implementation of CPIR in Fabric. Section~V evaluates performance. Section~VI discusses limitations and future directions, and Section~VII concludes the paper.

\section{PRELIMINARIES}\label{sec:preliminaries}

\subsection{TECHNOLOGY BACKGROUND}

\emph{a) Fabric Native Privacy Techniques:}
Hyperledger Fabric separates roles among endorsing peers, committing peers, and the ordering service. 
Endorsing peers execute chaincode proposals and therefore observe function arguments, logs, and read-sets, making their administrators the natural adversaries for read privacy. 
Protecting reads in Fabric thus requires hiding query intent from endorsers.

Fabric already offers several native privacy mechanisms, each addressing a different dimension of confidentiality:
\begin{itemize}
    \item \emph{Separate Channels.} Multi-channel partitioning isolates ledgers across subgroups of organizations, limiting which participants observe which data. 
    However, channel separation controls \emph{who} sees a ledger, not \emph{what} is accessed inside that ledger. 
    Query intent remains visible to all endorsers of a channel.
    
    \item \emph{Private Data Collections (PDC).} PDCs restrict which organizations store and access private key–value pairs. 
    The shared ledger records only hashes, while members of the collection hold plaintext. 
    PDCs provide access control but still expose function arguments to endorsers inside the collection, leaving query patterns observable.
    
    \item \emph{Fabric Private Chaincode (FPC).} FPC executes chaincode within Intel SGX enclaves. 
    Arguments and state are protected even from peer operators, but this requires Trusted Execution Environments (TEEs) and attestation, introducing additional hardware and trust assumptions.
\end{itemize}

In summary, Fabric’s native privacy tools govern data visibility and execution confidentiality. 
They are orthogonal to Private Information Retrieval (PIR): PDC and FPC restrict who can see data, while PIR hides what data is queried.


\emph{b) Private Information Retrieval Basics:}
PIR protocols enable a client to retrieve a record without revealing which record was requested. 
They fall into two categories:

\emph{Information-Theoretic PIR (IT-PIR).} Provides unconditional privacy by distributing the database across multiple non-colluding servers. 
A client queries subsets of servers such that no single server learns the selection index.

\emph{Computational PIR (CPIR).} Achieves privacy with a single server, relying on hardness assumptions and homomorphic encryption. 
For a database $D=\{d_0,\dots,d_{n-1}\}$ and a one-hot selection vector $\hat{v}_i$, the client computes 
\[
ct_q = \text{Enc}_{pk}(\hat{v}_i), \qquad ct_r = ct_q \cdot D = \text{Enc}_{pk}(d_i).
\]
The server returns $c_r$, which the client decrypts as $d_i = \text{Dec}_{sk}(c_r)$. 
Thus the queried index $i$ remains hidden from the server.

CPIR avoids the need for multiple servers, making it attractive in blockchain settings where peers cannot be assumed non-colluding.
%\noindent 

\emph{c) BGV Homomorphic Encryption:}
Our construction relies on the Brakerski–Gentry–Vaikuntanathan (BGV) scheme, a lattice-based homomorphic encryption system supporting both addition and multiplication over ciphertexts. 
BGV is defined over polynomial rings modulo a large ciphertext modulus and enables \emph{batching}, where multiple plaintext elements are packed into a single ciphertext. 
In our design, this batching is used to embed the ledger’s key–value table into a single polynomial $m_{\mathrm{DB}}$, allowing efficient evaluation of structured PIR queries inside chaincode and underpins the polynomial database representation used in our Fabric integration.

\subsection{NOTATION}
We summarize the main notation used throughout the paper in Table~\ref{tab:notation}.

\begin{table}[!t]
    \caption{Notation}
    \label{tab:notation}
    \setlength{\tabcolsep}{3pt}
    \renewcommand{\arraystretch}{1.1}
        \begin{tabular}{|p{78pt}|p{170pt}|}
        \hline
        \textbf{Symbol} & \textbf{Description} \\
        \hline
        $\lambda$ & Security parameter \\
        \hline
        $n$ & Database size; index domain $[n]=\{0,\dots,n-1\}$ \\
        \hline
        $D=\{d_0,\dots,d_{n-1}\}$ & Database records (serialized bytes/words) \\
        \hline
        $m_{\mathrm{DB}}$ & Plaintext polynomial representation of $D$ (BGV batching) \\
        \hline
        $\hat{v}_i$ & One-hot selector for index $i$ (single 1, rest 0) \\
        \hline
        ${v}_i$ & Windowed selector for index $i$ with $record_s$ contiguous ones (retrieves full record window) \\
        \hline
        $pk,\, sk$ & Public / secret keys (BGV) \\
        \hline
        $ct_q=\mathsf{Enc}_{pk}(\hat{v}_i)$ & Encrypted query \\
        \hline
        $ct_r=\mathsf{Eval}(ct_q, m_{\mathrm{DB}})$ & Encrypted response \\
        \hline
        $d_i=\mathsf{Dec}_{sk}(ct_r)$ & Decrypted record $d_i$ retrieved by client \\
        \hline
        $\mathsf{KeyGen}(\lambda)\!\to\!(pk,sk)$ & Key generation \\
        \hline
        $\mathsf{Enc}_{pk}(\cdot)$, $\mathsf{Dec}_{sk}(\cdot)$ & Encrypt / Decrypt \\
        \hline
        $\mathsf{Eval}(\cdot)$ & Homomorphic evaluation (ct–pt multiply) \\
        \hline
        $N=2^{\log N}$ & Ring dimension (polynomial degree of the scheme) \\
        \hline
        $\log Q_i$ & Bit-lengths of primes forming modulus chain $Q$ (ciphertext levels) \\
        \hline
        $\log P_i$ & Bit-lengths of special primes $P$ (used for key switching / relinearization) \\
        \hline
        $T$ & Plaintext modulus (NTT-friendly prime; Lattigo \texttt{PlaintextModulus}) \\
        \hline
        $record_s$ & Slots allocated per record (slot window size) \\
        \hline
        $record_b$ & Base serialized size of a record in bytes \\
        \hline
        $record_{\mu,\log N}$ & Template-specific minimum record size at security level $\log N$ \\
        \hline
        $\mathcal{S}$ & Allowed discrete slot sizes (implementation policy) \\
        \hline
        ${c}=(c_0,\dots,c_{N-1})$ & Coefficient vector of the polynomial encoding (slots of $m_{\mathrm{DB}}$) \\
        \hline
        $|\cdot|$, $\mathrm{size}(\cdot)$ & Length in elements / size in bytes \\
        \hline
        $\mathsf{Cap}(N,s,n)$ & Capacity predicate: $n \cdot s \leq N$ \\
        \hline
        $\mathsf{Min}(\log N,s)$ & Template predicate: $s \geq record_{\mu,\log N}$ \\
        \hline
        $\mathsf{Disc}(s)$ & Discrete predicate: $s \in \mathcal{S}$ \\
        \hline
        $\mathsf{Cap} \wedge \mathsf{Min} \wedge \mathsf{Disc}$ & Feasibility condition for $(\log N,n,record_s)$ \\
        \hline
        $\mathcal{DO},\,\mathcal{DW},\,\mathcal{DR},\,\mathcal{GW}$ & Data Owner; Data Writer; Data Requester; Gateway \\
        \hline
        \textsf{evaluate}, \textsf{submit} & Fabric read / write transaction phases \\
        \hline
        $\mathcal{L}$ & Leakage considered (ciphertext size, protocol timing) \\
        \hline
        \end{tabular}
    \end{table}
    

\subsection{CRYPTOGRAPHIC PRIMITIVES}

The Brakerski--Gentry--Vaikuntanathan (BGV) scheme defines operations over two polynomial rings: 
a ciphertext ring $R_Q = \mathbb{Z}_Q[X]/(X^N+1)$ and a plaintext ring $R_T = \mathbb{Z}_T[X]/(X^N+1)$, 
both sharing the same dimension $N=2^{\log N}$. 
In our implementation, these rings are jointly specified by a single parameter literal 
$(\log N, \log Q_i, \log P_i, T)$ as provided by the Lattigo library. 
The field $T$ determines $R_T$, while the modulus chain $(Q,P)$ and their bit-lengths $(\log Q_i, \log P_i)$ determine $R_Q$.

We instantiate Computational PIR as a tuple of probabilistic polynomial-time algorithms
\[
\Pi = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Eval}, \mathsf{Dec}),
\]
defined as follows:
\begin{itemize}
    \item $\mathsf{KeyGen}(\lambda) \rightarrow (pk, sk)$: On input the security parameter $\lambda$, output a public key $pk$ and a secret key $sk$.
    \item $\mathsf{Enc}_{pk}(\hat{v}_i) \rightarrow ct_q$: Given a windowed selection vector $\hat{v}_i \in \{0,1\}^N$, encode it into the plaintext ring $R_T$ and encrypt to a query ciphertext $ct_q$ under $pk$.
    \item $\mathsf{Eval}(ct_q, m_{\mathrm{DB}}) \rightarrow ct_r$: Given $ct_q$ and the plaintext polynomial database $m_{\mathrm{DB}} \in R_T$, homomorphically evaluate the product to obtain an encrypted response $ct_r \in R_Q$.
    \item $\mathsf{Dec}_{sk}(ct_r) \rightarrow d_i$: Using the secret key $sk$, decrypt the response ciphertext $ct_r$ to recover the desired record $d_i$.
\end{itemize}

\noindent \textbf{Protocol objective.} 
Correctness requires that for all $i \in [n]$,
\[
\mathsf{Dec}_{sk}\!\left(\mathsf{Eval}\!\left(\mathsf{Enc}_{pk}(\hat{v}_i), m_{\mathrm{DB}}\right)\right) = d_i.
\]

\noindent \textit{Remark (restricted operation set).} 
The full BGV scheme also provides $\mathsf{EvalKeyGen}$ to generate relinearization and rotation keys, 
supporting ciphertext–ciphertext multiplication, automorphisms, and modulus switching. 
Our PIR construction requires only ciphertext–plaintext multiplication ($ct \times pt$), 
since the database polynomial $m_{\mathrm{DB}}$ is kept in plaintext within world state. 
This avoids degree growth and level management, so we do not expose $\mathsf{EvalKeyGen}$ in chaincode. 
Extending to ciphertext–ciphertext evaluation would require additional on-chain artifacts 
(relinearization keys, Galois keys, encrypted $m_{\mathrm{DB}}$), larger world-state footprint, and higher evaluation cost, 
which we leave as future work.
    
\section{PROPOSED SYSTEM}\label{sec:proposed_system}
The following subsections detail (i) the system and threat models, (ii) a system overview, 
(iii) the polynomial database construction, (iv) feasibility constraints for parameter selection, 
(v) multi-channel architecture, (vi) workflow details and main 5 algorithms.

\subsection{SYSTEM MODEL}
We introduce a blockchain-based query privacy system designed for permissioned ledgers. 
The system enables clients to privately retrieve from the ledger while endorsing peers can evaluate read-only queries over encrypted inputs without learning which record was accessed.  
The novelty of our approach lies in the integration of computational Private Information Retrieval (CPIR) into Hyperledger Fabric chaincode using the Brakerski--Gentry--Vaikuntanathan (BGV) homomorphic encryption scheme. 
This approach ensures that clients remain the sole holders of decryption keys, while peers perform only black-box computations, thereby enhancing overall privacy without requiring trusted hardware or protocol modifications.

\noindent Our system is composed of the following entities:

\begin{itemize}
    \item \textbf{Data Owner ($\mathcal{DO}$):} Endorsing peers that hold the current plaintext polynomial $m_{\mathrm{DB}}$ in world state and execute PIR during \textsf{evaluate}. $\mathcal{DO}$ is honest-but-curious.
    \item \textbf{Data Writer ($\mathcal{DW}$):} A client organization that provisions or refreshes the database. $\mathcal{DW}$ invokes \textsf{submit} to initialize the ledger (e.g., set $n$ and template bounds). Chaincode computes $record_s$, packs $D=\{d_0,\dots,d_{n-1}\}$, encodes it into $m_{\mathrm{DB}}$, and persists it.
    \item \textbf{Data Requester ($\mathcal{DR}$):} A client that privately retrieves a record. $\mathcal{DR}$ runs $\mathsf{KeyGen}(\lambda)\!\to\!(pk,sk)$, forms $ct_q=\mathsf{Enc}_{pk}(v_i)$, calls \textsf{evaluate} \textsf{PIRQuery}, and later decrypts $ct_r$.
    \item \textbf{Gateway ($\mathcal{GW}$):} The Fabric client/chaincode interface used by $\mathcal{DW}$ and $\mathcal{DR}$ to invoke \textsf{InitLedger}, \textsf{GetMetadata}, and \textsf{PIRQuery}. It follows standard Fabric semantics; no extra trust is assumed.
\end{itemize}

\noindent\textit{Remark (world-state scope).} In Fabric, the "ledger" comprises the blockchain log and the world state. Our CPIR operates on the world state: $m_{\mathrm{DB}}$ encodes the latest key--value snapshot, not the historical transaction logs.

\subsection{THREAT MODEL}

Our design follows the standard \emph{honest-but-curious} adversarial model. 
We explicitly consider the following assumptions and threats:

\begin{itemize}
    \item \textbf{Endorsing peers ($\mathcal{DO}$).} Execute chaincode correctly but may try to infer the queried index from \textsf{evaluate} inputs or logs. They see $ct_q$, metadata, and $m_{\mathrm{DB}}$.
    \item \textbf{Data Writer ($\mathcal{DW}$).} Issues initialization writes via \textsf{submit}. $\mathcal{DW}$ is not trusted with decryption keys and learns nothing about $\mathcal{DR}$’s queries. We assume $\mathcal{DW}$ follows the write protocol but is not relied upon for privacy.
    \item \textbf{External observers.} May eavesdrop on client–peer traffic. Without $sk$, $ct_q$ and $ct_r$ reveal nothing under BGV assumptions.
    \item \textbf{Out of scope.} Traffic analysis and timing side-channels; the only permitted leakage is $\mathcal{L}$ (ciphertext size and protocol timing).
\end{itemize}

\noindent \textbf{Security objective.} 
For any $i\in[n]$, neither $\mathcal{DO}$ nor external observers can distinguish which $d_i$ is requested from $ct_q$ and $ct_r$.
The only permissible leakage is ciphertext size and protocol timing, denoted collectively as $\mathcal{L}$.


\subsection{SYSTEM OVERVIEW}

The proposed system integrates computational Private Information Retrieval (CPIR) directly into Hyperledger Fabric chaincode. 
Its purpose is to ensure that query indices remain hidden from endorsing peers while preserving Fabric’s endorsement and audit workflow. 
At a high level, the workflow consists of four stages, illustrated in Fig.~\ref{fig:system-overview}.

\begin{enumerate}
    \item \textbf{Ledger initialization.}
    $\mathcal{DW}$ invokes \textsf{InitLedger} via $\mathcal{GW}$ using \textsf{submit}. Chaincode derives $record_s$ from $record_b$, packs $D$ into ${c}=(c_0,\dots,c_{N-1})$, encodes $m_{\mathrm{DB}}$, and stores $m_{\mathrm{DB}}$ and metadata in world state held by $\mathcal{DO}$.
    \item \textbf{Metadata discovery.}
    $\mathcal{DR}$ calls \textsf{GetMetadata} via \textsf{evaluate} to obtain $n$, $record_s$, and BGV parameters needed to form a valid query.
    \item \textbf{Private retrieval.}
    $\mathcal{DR}$ constructs $ct_q=\mathsf{Enc}_{pk}(v_i)$ and invokes \textsf{PIRQuery} via \textsf{evaluate}. $\mathcal{DO}$ computes $ct_r=\mathsf{Eval}(ct_q,m_{\mathrm{DB}})$ and returns it.
    \item \textbf{Decryption.}
    $\mathcal{DR}$ decrypts $ct_r$ to recover $d_i=\mathsf{Dec}_{sk}(ct_r)$.
\end{enumerate}

\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{figures/diagrams/1_workflow.png}
    \caption{“Workflow. $\mathcal{DW}$ initializes the ledger via $\mathcal{GW}$, which triggers chaincode on endorsing peers ($\mathcal{DO}$). $\mathcal{DO}$ executes the protocol and persists state in world state ($m_{\mathrm{DB}}$, metadata, JSON records). $\mathcal{DR}$ later obtains metadata, submits $ct_q=\mathsf{Enc}{pk}(v_i)$, $\mathcal{DO}$ evaluates $ct_r=\mathsf{Eval}(ct_q,m{\mathrm{DB}})$ against world state, and $\mathcal{DR}$ decrypts to $d_i$.}
    \label{fig:system-overview}
\end{figure}

\subsection{POLYNOMIAL DATABASE CONSTRUCTION}

To enable PIR queries over structured ledger data, we must embed records into a plaintext polynomial $m_{\mathrm{DB}}$ suitable for BGV evaluation. 
Our prototype adopts a fixed-width packing strategy, illustrated in Fig.~\ref{fig:polynomial-construction}, which proceeds in four steps.

\begin{figure*}[!t]
    \centering
    \includegraphics[width=\textwidth]{figures/diagrams/2_polynomial_construction.png}
    \caption{$m_{\mathrm{DB}}$ construction from JSON to plaintext polynomial. 
    Each record is serialized to bytes, mapped into a fixed slot window $record_s$, and packed into a coefficient vector $c$. 
    The vector is then encoded as a BGV plaintext polynomial $m_{\mathrm{DB}}$, which is stored in the Fabric world state.}
    \label{fig:polynomial-construction}
\end{figure*}

\textbf{Step 1: Serialize to Byte Array.}
Each ledger record $d_i$ is serialized as a UTF-8 byte array. 
In our motivating use case of Cyber Threat Intelligence (CTI) sharing, JSON objects containing fields such as hash digests and threat levels are flattened into byte sequences. 
Every character is represented by its ASCII code in $[0,255]$. 
This ensures that arbitrary structured records can be embedded in the polynomial without loss of information.

\textbf{Step 2: Calculate Slot Window.} 
We determine the slot allocation per record as:
\[
record_s = \left\lceil \frac{record_b}{\textit{bytesPerSlot}} \right\rceil,
\]
where $record_b$ is the maximum serialized record length observed in bytes.  
In our prototype, each slot stores exactly one byte.  
For example, if the largest record is $126$ bytes, then $record_s = \lceil 126/1 \rceil = 126$, which rounds up to $128$ slots due to the discrete window policy.  
This guarantees uniform slot windows across all records, simplifying query construction at the cost of potential padding overhead.

\textbf{Step 3: Pack into Coefficient Vector.} 
Serialized byte arrays are inserted into disjoint slot windows of length $record_s$ within a coefficient vector 
$c = (c_0, c_1, \dots, c_{N-1})$,  
where $N = 2^{\log N}$ is the ring capacity of the BGV scheme. 
Padding zeros are added if a record is shorter than $record_s$.  
Thus each record $d_i$ occupies a contiguous slot interval that can be privately retrieved through PIR.

\textbf{Step 4: Encode into Polynomial.} 
Finally, the coefficient vector $d$ is encoded into a plaintext polynomial:
\[
m_{\mathrm{DB}}(X) = \sum_{j=0}^{N-1} c_j X^j \in R_t,
\]
where $R_t = \mathbb{Z}_t[X]/(X^N+1)$. 
This polynomial serves as the plaintext database representation stored in the Fabric world state. 
Endorsing peers operate over $m_{\mathrm{DB}}$ during PIR queries, while clients recover only the slots corresponding to their requested record.

\subsection{FEASIBILITY CONSTRAINTS}

Embedding records into the plaintext polynomial $m_{\mathrm{DB}}$ is feasible only for parameter triples 
$(\log N, n, record_s)$ that satisfy \emph{all} of the following constraints. 
These constraints form a hierarchical relationship: template requirements dominate discrete allocation, 
and both are ultimately bounded by ring capacity.

\textbf{Constraint 1: Ring capacity.}
The total number of occupied slots cannot exceed the ring size:
\[
n \cdot record_s \ \leq \ N.
\]
This represents the fundamental mathematical limit imposed by the cryptographic parameters. 
For example, with $\log N = 13$ ($N = 8192$) and $record_s = 224$, 
at most $\lfloor 8192/224 \rfloor = 36$ records can be packed.

\textbf{Constraint 2: Template-specific minima.}
Each security level ($\log N$) corresponds to a record template with mandatory fields 
that impose a minimum slot requirement $record_{\mu,\log N}$. Examples include:
\begin{itemize}
    \item \textbf{Mini records} ($\log N = 13$): MD5 hash + malware family + threat level $\;\;\Rightarrow\;\; record_{\mu,13} \approx 128$ bytes.
    \item \textbf{Mid records} ($\log N = 14$): MD5 + SHA-256 short + malware class + AV detects $\;\;\Rightarrow\;\; record_{\mu,14} \approx 224$ bytes.
    \item \textbf{Rich records} ($\log N = 15$): MD5 + full SHA-256 + all metadata $\;\;\Rightarrow\;\; record_{\mu,15} \approx 256$ bytes.
\end{itemize}

These minima arise from generator checks of the form:
\[
\begin{aligned}
    \textsf{Mini:}\quad & record_s \ \geq \ record_b + 32 + 15, \\
    \textsf{Mid:}\quad  & record_s \ \geq \ record_b + 32 + 16 + 15, \\
    \textsf{Rich:}\quad & record_s \ \geq \ record_b + 32 + 64 + 15,
\end{aligned}
\]
where $record_b \approx 113$--125 bytes denotes the base JSON structure 
and numeric terms represent mandatory hash fields and serialization overhead.

\textbf{Constraint 3: Discrete allocation policy.}
Operationally, we restrict the slot window $record_s$ to a discrete set for implementation simplicity:
\[
\mathcal{S} = \{64, 128, 224, 256, 384, 512\} \ \text{bytes}.
\]
This means that even if Constraints~1 and~2 are satisfied, 
the configuration is rejected unless $record_s \in \mathcal{S}$.

\noindent\textbf{Constraint hierarchy and feasibility.}
Feasibility of a configuration $(\log N,n,record_s)$ is defined by three predicates:
\begin{align*}
\mathsf{Cap}(N,s,n) &: n \cdot s \leq N \quad \text{(ring capacity)} \\
\mathsf{Min}(\log N,s) &: s \geq record_{\mu,\log N} \quad \text{(template minimum)} \\
\mathsf{Disc}(s) &: s \in \mathcal{S} \quad \text{(discrete allocation)} .
\end{align*}
where $s=record_s$ and $N=2^{\log N}$. A configuration is feasible iff:
\[
\mathsf{Cap}(N,s,n)\ \wedge\ \mathsf{Min}(\log N,s)\ \wedge\ \mathsf{Disc}(s).
\]

\noindent\textbf{Examples.} The interaction of these predicates is illustrated in Fig.~\ref{fig:exp-matrix}. We provide three concrete examples below:

\noindent\emph{a) Polynomial degree} $\log N=13$ (Mini):
\begin{itemize}
    \item $\mathsf{Min}(13,s)$ enforces $s \geq record_{\mu,13} \approx 128$ $\Rightarrow$ the smallest candidate is $s=128$.
    \item $\mathsf{Disc}(s)$ requires $s \in \mathcal{S}$ $\Rightarrow$ $128$ is allowed (while $64$ is invalid).
    \item $\mathsf{Cap}(8192,128,n)$ gives $n \leq \lfloor 8192/128 \rfloor = 64$.
    \item \emph{Feasible:} $(\log N=13,s=128,n \leq 64)$.
\end{itemize}

\noindent\emph{b) Polynomial degree} $\log N=14$ (Mid):
\begin{itemize}
    \item $\mathsf{Min}(14,s)$ enforces $s \geq record_{\mu,14} \approx 224$ $\Rightarrow$ smallest candidate is $224$.
    \item $\mathsf{Disc}(s)$ allows $224,256,\dots$ but excludes smaller windows.
    \item $\mathsf{Cap}(16384,224,n)$ gives $n \leq \lfloor 16384/224 \rfloor = 73$.
    \item \emph{Feasible:} $(\log N=14,s \in \{224,256,\dots\},n \leq 73)$.
\end{itemize}

\noindent\emph{c) Polynomial degree} $\log N=15$ (Rich): 
\begin{itemize}
    \item $\mathsf{Min}(15,s)$ enforces $s \geq record_{\mu,15} \approx 256$.
    \item $\mathsf{Disc}(s)$ excludes $64,128,224$; smallest valid is $256$.
    \item $\mathsf{Cap}(32768,256,n)$ gives $n \leq \lfloor 32768/256 \rfloor = 128$.
    \item \emph{Feasible:} $(\log N=15,s \geq 256,n \leq 128)$.
\end{itemize}

\noindent\textbf{Implications.} Increasing $\log N$ raises ring capacity $N$ and thus $n$, but also requires larger $record_s$ if given richer templates. Feasible configurations occur only where all 3 predicates are met, guiding practical parameter selection.
\begin{figure}[!h]
    \centering
    \includegraphics[width=\columnwidth]{figures/diagrams/3_feasible_configs.png}
    \caption{Feasible configurations under the joint constraints $\mathsf{Cap}$, $\mathsf{Min}$, and $\mathsf{Disc}$. Dashed curves show ring-capacity limits for $\log N \in \{13,14,15\}$, vertical lines mark template-driven minima $record_{\mu,\log N}$, and x-axis ticks correspond to discrete slot sizes $\mathcal{S}$. Circles indicate feasible triples $(\log N,record_s,n)$.}
    \label{fig:exp-matrix}
\end{figure}

\begin{figure*}[!h]
    \centering
    \includegraphics[width=\textwidth]{figures/diagrams/4_multi_channel_arc.png}
    \caption{Multi-channel CPIR architecture. 
    Each channel instantiates a separate CPIR chaincode and maintains its own $m_{\mathrm{DB}}$ polynomial, 
    parameterized by $\log N$. This allows compact, mid-size, and rich CTI records to coexist under the same Fabric network.}
    \label{fig:multi-channel}
\end{figure*}

\subsection{MULTI-CHANNEL ARCHITECTURE}

The packing strategy and feasibility constraints highlight an important observation: 
no single homomorphic parameter set can efficiently support the full diversity of Cyber Threat Intelligence (CTI) record formats. 
Compact records fit comfortably under smaller rings, while full JSON objects with long cryptographic hashes exceed the slot budget of these configurations. 
To balance scalability and expressiveness, we design a \emph{multi-channel architecture} in Hyperledger Fabric 
(Fig.~\ref{fig:multi-channel}), 
where each channel is provisioned with a distinct BGV parameter set and record template.

\textbf{a) Channel Mini} ($\log N=13$).  
Supports compact CTI records (e.g., MD5, malware family, threat level) with maximum scalability and lowest query latency. 
For example, with $N=8192$ slots, the system accommodates up to 128 records when $\max_i |d_i| \leq 64$ bytes, 
and 16 records when $\max_i |d_i| \leq 512$ bytes.

\textbf{b) Channel Mid} ($\log N=14$).  
Targets medium-sized records that include MD5 and truncated SHA-256 fields alongside classification metadata. 
With $N=16384$ slots, the system supports up to 256 records at $\leq 64$ bytes or 32 records at $\leq 512$ bytes.

\textbf{c) Channel Rich} ($\log N=15$).  
Handles the most detailed records, including full-length hashes and multiple metadata fields. 
Here, $N=32768$ slots allow up to 512 records at $\leq 64$ bytes or 64 records at $\leq 512$ bytes.

\noindent\textbf{Channel semantics.}  
As shown in Fig.~\ref{fig:multi-channel}, each channel maintains its own PIR chaincode instance and world state. 
The world state contains:
\begin{itemize}
    \item The \emph{polynomial view}: the packed plaintext polynomial $m_{\mathrm{DB}}$ under key \texttt{"m\_DB"}.
    \item The \emph{normal view}: JSON records stored individually under keys \texttt{"record\%03d"} for auditability and interoperability with non-PIR chaincode.
    \item \emph{Metadata}: 
    \begin{itemize}
        \item \texttt{"n"}: number of records $n$,
        \item \texttt{"record\_s"}: slots per record $record_s$,
        \item \texttt{"bgv\_params"}: $\{\log N, N, \log Q_i, \log P_i, T\}$.
    \end{itemize}
\end{itemize}

\noindent\textit{Remark (ledger capacity).}
A practical concern is the maximum size of the ledger when channels store both JSON records and the polynomial $m_{\mathrm{DB}}$. 
In Hyperledger Fabric, two layers impose size-related limits: the \emph{world state} (LevelDB or CouchDB) and the \emph{blockchain history} managed by the ordering service.

\textbf{a) World state (LevelDB/CouchDB).}
Fabric imposes no hard limit on the number of key–value entries in world state; capacity depends on available disk space and peer I/O throughput.
In our implementation, each channel maintains a few small keys:
\texttt{"m\_DB"} (64–265~KB), \texttt{"n"}, \texttt{"record\_s"}, \texttt{"bgv\_params"}, and optional \texttt{"record\%03d"} JSON records.
These sizes are well within the default LevelDB storage profile, which is optimized for high-speed local key–value operations.
Although CouchDB can be used as an alternative (for rich JSON queries), it enforces a configurable \texttt{max\_document\_size} limit of 8~MB by default (up to 4~GB in recent versions of CouchDB~3.0+).
Since our $m_{\mathrm{DB}}$ values are below 300~KB, LevelDB is sufficient and preferable for performance and simplicity, while CouchDB remains compatible for future extensions that require JSON-based indexing.

\textbf{b) Ledger history (blockchain log).}
Block size is constrained by the ordering service configuration. 
By default, the Fabric orderer limits the serialized payload to \texttt{AbsoluteMaxBytes~=~10~MB} (recommended under 49~MB given the gRPC ceiling of 100~MB), 
and typically aggregates up to \texttt{MaxMessageCount~=~500} transactions per block or \texttt{PreferredMaxBytes~=~2~MB}.
In our system, these limits affect only \textsf{submit} transactions such as \textsf{InitLedger} or record updates. 
\textsf{Evaluate} transactions (including \textsf{PIRQuery}) are read-only and do not generate blocks, thus unaffected by ordering or batching constraints.

\noindent\textbf{Implication.}
The effective capacity of a channel is governed primarily by cryptographic feasibility (Fig.~\ref{fig:exp-matrix}) 
and the size of a single world-state value (i.e., $m_{\mathrm{DB}}$), rather than by Fabric’s block or database limits. 
For large or binary CTI objects (e.g., malware samples or full PCAPs), an optional extension is to store them off-chain in IPFS 
while persisting only their content identifiers (CIDs) in world state, 
keeping the polynomial $m_{\mathrm{DB}}$ as the structured component used for private retrieval.

\subsection{WORKFLOW DETAILS}

The complete workflow of our CPIR-enabled Fabric system is driven by five algorithms 
(Alg.~\ref{alg:initledger}–\ref{alg:decryptresult}), corresponding to the chaincode interface 
(\textsf{InitLedger}, \textsf{GetMetadata}, \textsf{PIRQuery}) and the client-side routines 
(\textsf{FormSelectionVector}, \textsf{DecryptResult}). 
Figure~\ref{fig:system-overview} provides the high-level overview. 
A Data Writer ($\mathcal{DW}$) provisions the database $D=\{d_0,\dots,d_{n-1}\}$, 
a Data Owner ($\mathcal{DO}$) maintains the polynomial $m_{\mathrm{DB}}$ in world state and executes PIR evaluations, 
and a Data Requester ($\mathcal{DR}$) retrieves $d_i$ privately using homomorphic encryption.
The detailed steps are as follows:
\begin{enumerate}
    \item \textbf{DW submits initialization.}  
    $\mathcal{DW}$ calls \textsf{InitLedger} (Alg.~\ref{alg:initledger}) via $\mathcal{GW}$ (\textsf{submit}) 
    with inputs $(n,\,record_{s}^{\mathcal{DW}})$ and an optional hint $(\log N,\log Q_i,\log P_i,T)$. 
    Here $record_{s}^{\mathcal{DW}}$ denotes the maximum JSON size anticipated by the writer. 

    \item \textbf{DO validates and derives parameters.}  
    $\mathcal{DO}$ rounds the writer’s input to a discrete slot size 
    $record_{s}^{\mathcal{GW}} = 8 \cdot \lceil record_{s}^{\mathcal{DW}} / 8 \rceil$. 
    If $\log N$ is absent, the smallest feasible $\log N$ is chosen such that 
    $\mathsf{Cap}(N,record_{s}^{\mathcal{GW}},n)$ holds. 
    BGV parameters $\{\log N,N,\log Q_i,\log P_i,T\}$ are constructed and stored.

    \item \textbf{DO prepares records.}  
    Records $D=\{d_0,\dots,d_{n-1}\}$ are ingested or synthesized with $|d_i|\le record_{s}^{\mathcal{DW}}$. 
    The definitive slot allocation is then fixed as 
    $record_s = 8 \cdot \lceil \max_i |d_i| / 8 \rceil$ (discrete policy), 
    checked against feasibility predicates 
    $\mathsf{Min}(\log N,record_s)$, $\mathsf{Disc}(record_s)$, $\mathsf{Cap}(N,record_s,n)$. 

    \item \textbf{Pack and persist.}  
    Each $d_i$ is placed in a disjoint window $J_i=\{i\cdot record_s,\dots,(i+1)record_s-1\}$ of $c=(c_0,\dots,c_{N-1})$, 
    zeros pad unused slots, and the polynomial $m_{\mathrm{DB}}(X)=\sum c_j X^j$ is encoded at max level. 
    World state stores \texttt{"m\_DB"}, \texttt{"n"}, \texttt{"record\_s"}, and \texttt{"bgv\_params"} 
    plus optional \texttt{"record\%03d"} entries. 

    \item \textbf{DR discovers metadata.}  
    $\mathcal{DR}$ calls \textsf{GetMetadata} (Alg.~\ref{alg:getmetadata}) via \textsf{evaluate} 
    to obtain $(n,record_s,\log N,N,T,\log Q_i,\log P_i)$. 
    This enables reconstruction of the cryptographic context. 

    \item \textbf{DR instantiates crypto context.}  
    From metadata, $\mathcal{DR}$ builds parameters, executes $\mathsf{KeyGen}(\lambda)\!\to\!(pk,sk)$, 
    and prepares encoder/encryptor objects. 

    \item \textbf{Form and encrypt query.}  
    For index $i\in[n]$, $\mathcal{DR}$ runs \textsf{FormSelectionVector} (Alg.~\ref{alg:encryptquery}): 
    define $J_i$, set ${v}_i$ with ones on $J_i$, encode to $m_q(X)$, encrypt as $ct_q=\mathsf{Enc}_{pk}({v}_i)$, 
    and serialize/Base64-encode. 

    \item \textbf{PIR query evaluation.}  
    $\mathcal{DR}$ issues \textsf{PIRQuery}($ct_q^{B64}$) (Alg.~\ref{alg:pirquery}) via \textsf{evaluate}. 
    $\mathcal{DO}$ decodes, reloads $m_{\mathrm{DB}}$ if necessary, and computes 
    $ct_r=\mathsf{Eval}(ct_q,m_{\mathrm{DB}})$, returning the Base64-encoded ciphertext. 

    \item \textbf{Decryption and reconstruction.}  
    $\mathcal{DR}$ runs \textsf{DecryptResult} (Alg.~\ref{alg:decryptresult}) to recover $m'(X)$, 
    extract bytes from $J_i$, stop at padding zero, and reconstruct $d_i$ as a valid JSON object 
    (or a scalar if $record_s=1$).
\end{enumerate}

\noindent\textit{Remark (levels, noise, determinism).}
Queries are encoded and encrypted at \emph{max level}. Chaincode evaluates a single ct–pt multiply (no relinearization).
This keeps noise growth minimal and evaluation deterministic across endorsers, which is important for Fabric endorsement.
If $m_{\mathrm{DB}}$ is re-encoded or refreshed, $\mathcal{GW}$ still returns the same metadata blob; clients rebuild context idempotently.

\begin{algorithm}[!h]
    \caption{InitLedger (chaincode)}
    \label{alg:initledger}
    \begin{algorithmic}[1]
    \REQUIRE $n$; $record_s^{\mathcal{DW}}$; op: $\mathrm{hint}$
    \STATE $\log N \leftarrow \selMinLogN{\!\left(n,\,8 \cdot \left\lceil \tfrac{record_s^{\mathcal{DW}}}{8} \right\rceil\right)}$
    \IF {$\log N=\varnothing$} 
        \STATE \textbf{return} $\bot$ 
    \ENDIF
    \STATE $bgvParams \gets \selParams{(\log N,\, op:\mathrm{hint})}$
    \STATE $D \gets \genRecords{(n,\,record_s^{\mathcal{DW}})}$
    \IF {$\exists i:\ |d_i|>record_s^{\mathcal{DW}}$} 
        \STATE \textbf{return} $\bot$ 
    \ENDIF
    \STATE $record_s \gets 8 \cdot \left\lceil \dfrac{\max_i |d_i|}{8} \right\rceil$
    \IF{$\neg \feasible{\log N,n,record_s}$} 
        \STATE \textbf{return} $\bot$ // infeasible configuration
    \ENDIF

    \STATE $c \gets [0,\dots,0] \in \mathbb{Z}_T^N$ \hfill // init coefficient vector
\FOR{$i \in [0,n-1]$}
    \STATE $J_i \gets \{i\cdot record_s,\dots,(i+1)\cdot record_s-1\}$ \hfill // slot window for $d_i$
    \FOR{$k=0$ \TO $record_s-1$}
        \IF{$k < |d_i|$}
            \STATE $c[J_i[k]] \gets \textsf{byte}(d_i[k])$ \hfill // copy byte of record
        \ELSE
            \STATE $c[J_i[k]] \gets 0$ \hfill // padding
        \ENDIF
    \ENDFOR
\ENDFOR

    \STATE $m_{\mathrm{DB}}(X) \gets \encP{c} \in \mathbb{Z}_T[X]/(X^N+1)$
    \STATE $worldState \gets \{m_{\mathrm{DB}},\;n,\;record_s,\;bgvParams,\;op:D\}$
    \STATE \textbf{return} \textsc{ok}
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!h]
    \caption{GetMetadata (chaincode)}
    \label{alg:getmetadata}
    \begin{algorithmic}[1]
    \REQUIRE $\varnothing$
    \STATE $n \gets worldState.n$
    \STATE $record_s \gets worldState.record_s$
    \STATE $paramsMeta \gets worldState.bgvParams$
    \IF{$n=\varnothing \;\lor\; record_s=\varnothing \;\lor\; paramsMeta=\varnothing$}
    \STATE \textbf{return} $\bot$
    \ENDIF

    \STATE $paramsMeta=(\log N, N, \log Q_i[], \log P_i[], T)$
    \STATE $metadata \gets (n, record_s, paramsMeta)$
    \STATE \textbf{return} $metadata$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!h]
    \caption{FormSelectionVector (client)}
    \label{alg:encryptquery}
    \begin{algorithmic}[1]
    \REQUIRE $pk$; $i\in[n]$; $record_s$; $N$
    \IF{$i<0 \;\lor\; i\ge n$} \STATE \textbf{return} $\bot$ \ENDIF
    \IF{$n\cdot record_s > N$} \STATE \textbf{return} $\bot$ \ENDIF
    \STATE $J_i \gets \{i\cdot record_s,\dots,(i+1)\cdot record_s-1\}$
    \STATE ${v}_i \in \{0,1\}^{N} \gets \mathbf{0}$
    \FOR{$j \in J_i$} \STATE ${v}_i[j] \gets 1$ \ENDFOR \hfill // windowed selector
    \STATE $m_q(X) \gets \encP{{v}_i}$ \hfill // polynomial encode at max level
    \STATE $ct_q \gets \mathsf{Enc}_{pk}(m_q)$
    \STATE $ct_q^{B64} \gets \encB{\ser{ct_q}}$
    \STATE \textbf{return } $ct_q^{B64}$ \hfill // Base64(marshalled ciphertext)
    \end{algorithmic}
\end{algorithm}
    
\begin{algorithm}[!h]
    \caption{PIRQuery (chaincode)}
    \label{alg:pirquery}
    \begin{algorithmic}[1]
    \REQUIRE $ct_q^{B64}$
    \IF{$ct_q^{B64} = \varnothing$} 
        \STATE \textbf{return} $\bot$ 
    \ENDIF
    \STATE $ct_q \gets \des{\decB{(ct_q^{B64})}}$
    \IF{$m_{\mathrm{DB}}$ not cached in memory}
        \STATE $m_{\mathrm{DB}} \gets worldState.m_{\mathrm{DB}}$
    \ENDIF
    \STATE $ct_r \gets \mathsf{Eval}(ct_q, m_{\mathrm{DB}})$
    \STATE $ct_r^{B64} \gets \encB{\ser{(ct_r)}}$
    \STATE \textbf{return} $ct_r^{B64}$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!h]
    \caption{DecryptResult (client)}
    \label{alg:decryptresult}
    \begin{algorithmic}[1]
    \REQUIRE $ct_r^{B64}$; $sk$; $i\in[n]$; $record_s$; $n$
    \STATE \textbf{if } $i<0$ \textbf{ or } $i\ge n$ \textbf{ then return } $\bot$
    \STATE \textbf{if } $n\cdot record_s > N$ \textbf{ then return } $\bot$ \hfill // sanity
    \STATE $ct_r \leftarrow \des{\decB{(ct_r^{B64})}}$
    \STATE $u \in \mathbb{Z}_T^{N} \leftarrow \decP{\,m'(X)\,} \leftarrow \mathsf{Dec}_{sk}(ct_r)$
    \STATE $J_i \leftarrow \{i\cdot record_s,\dots,(i+1)\cdot record_s-1\}$
    \STATE $b \leftarrow$ byte array // init empty buffer for record
    \FOR{$j \in J_i$}
        \IF{$u[j]=0$} \STATE \textbf{break} \ENDIF \hfill // stop at padding zero
        \STATE $b.\mathsf{append}(u[j])$ 
    \ENDFOR
    \STATE \textbf{if } {$record_s=1$} \textbf{ then return } $u[i\cdot record_s]$
    \STATE $d_i \leftarrow {dec^{UTF8}}(b)$ 
    \STATE \textbf{return } $d_i$
    \end{algorithmic}
\end{algorithm}


\section{PERFORMANCE EVALUATION}
The following subsections detail (i) experimental setup and cryptographic benchmarks, 
(ii) fabric integration becnhmarks, 
(iii) discussion and comparison with related work.

\subsection{EXPERIMENTAL SETUP}

All experiments were executed on a local Ubuntu~24.04 host running under WSL2 on an Intel~Core~i5-3380M~CPU 
(2~cores/4~threads, 2.90~GHz) with 7.7~GB of RAM and a 1~TB~SSD. 
During evaluation, the average available memory was 6.9~GB with a 2~GB swap partition, 
and the root filesystem reported 946~GB of free space.

The software stack consisted of Go~1.24.1, Docker~27.4.0, and Docker~Compose~v2.31.0, 
hosting Hyperledger~Fabric~v2.5 with a single Raft orderer and LevelDB as the world-state database. 
Fabric’s ordering service used the recommended parameters 
(\texttt{BatchSize.AbsoluteMaxBytes}=99~MB, \texttt{PreferredMaxBytes}=2~MB per block).

Our implementation employs the \textit{Lattigo}~v6 library~\cite{lattigo2024} as the homomorphic encryption backend. 
Lattigo provides a Go-native implementation of the Brakerski–Gentry–Vaikuntanathan (BGV) scheme~\cite{brakerski2014leveled},
whose security and correctness have been validated in prior literature. 
Accordingly, our focus is on evaluating its \emph{practical performance within a permissioned blockchain environment}.

Client–peer communication was performed through the Fabric~Go~SDK (Gateway API). 
The network configuration comprised a single organization with one peer per channel, 
sufficient for privacy evaluation since PIR execution occurs solely at endorsing peers 
and ordering nodes do not access the world state. 
Unless otherwise stated, each reported value represents the mean of 20~executions under both cold and warm cache conditions, 
cross-verified against peer logs for consistency.

\subsection{CRYPTOGRAPHIC PERFORMANCE}

\noindent\textbf{Parameter Configuration.}
Table~\ref{tab:params} lists the main cryptographic parameters used in the evaluation, 
including the ring dimension $N$, modulus chain $(\log Q_i, \log P_i)$, plaintext modulus $T$, 
slot allocation $record_s$, number of records $n$, and selector type. 

\begin{table}[!h]
    \caption{Default BGV Parameter Configuration per Channel}
    \label{tab:params}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    $N$ & $\log Q_i$ & $\log P_i$ & $T$ & $record_s$ & $n$  \\
    \hline
    $2^{13}$ & [54] & [54] & 65537 & 128 & 64 \\
    $2^{14}$ & [54] & [54] & 65537 & 224 & 73 \\
    $2^{15}$ & [54] & [54] & 65537 & 256 & 128 \\
    \hline
    \end{tabular}
\end{table}


\noindent \textbf{End-to-End Latency by Stage.} Figure~\ref{fig:latency-stages} presents the breakdown of single-query latency 
across cryptographic operations for each ring size. 

\noindent \textbf{Artifact Size Analysis.} Figure~\ref{fig:artifact-sizes} reports the serialized size (in kilobytes) 
of the main cryptographic artifacts: the public and secret keys, the encrypted selector $ct_q$, the encrypted response $ct_r$,
the plaintext database polynomial $m_{\mathrm{DB}}$, and the metadata JSON object.

\noindent \textbf{Slot Utilization.}Figure~\ref{fig:scaling} illustrates the proportion of utilized versus 
unutilized slots across different ring sizes $N=2^{\log N}$.
Utilization $u=(n \cdot record_s)/N$ measures how efficiently plaintext slots are 
allocated within the polynomial database $m_{\mathrm{DB}}$.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\columnwidth]{figures/plots/e2e_latency_stacked.pdf}
    \caption{End-to-end single-query latency by stage; \texttt{ct×pt} path.}
    \label{fig:latency-stages}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=\columnwidth]{figures/plots/artifacts_sizes.pdf}
    \caption{Size of main cryptographic artifacts.}
    \label{fig:artifact-sizes}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=\columnwidth]{figures/plots/scaling_util_utilization_stacked.pdf}
    \caption{Allocated-slot utilization by ring. Each bar shows the fraction of utilized versus unutilized slots in $m_{\mathrm{DB}}$.}
    \label{fig:scaling}
\end{figure}

\noindent Having characterized the cryptographic performance of the BGV-based CPIR scheme 
in isolation—covering latency, artifact size, and slot utilization—we now turn to its 
\textbf{on-chain execution behavior within Hyperledger Fabric}. 
The following subsection measures the performance of the chaincode functions 
(\textsf{InitLedger}, \textsf{GetMetadata}, and \textsf{PIRQuery}) 
across channels, focusing on peer-side latency, throughput, and world-state footprint.

\subsection{BLOCKCHAIN PERFORMANCE}

\begin{figure*}[!ht]
    \centering
    \includegraphics[width=\textwidth]{figures/plots/plate_wide3x2.pdf}
    \caption{$m_{\mathrm{DB}}$ construction from JSON to plaintext polynomial. 
    Each record is serialized to bytes, mapped into a fixed slot window $record_s$, and packed into a coefficient vector $c$. 
    The vector is then encoded as a BGV plaintext polynomial $m_{\mathrm{DB}}$, which is stored in the Fabric world state.}
    \label{fig:polynomial-construction}
\end{figure*}

\textbf{a) Chaincode Execution Timings.}
Figure~\ref{fig:chaincode-timings} and Table~\ref{tab:chaincode-timings} summarize the average \textit{server-side execution time} of 
the main chaincode functions across different ring sizes $N=2^{\log N}$. 

\begin{table}[!h]
    \caption{Average chaincode execution time (ms) per function and ring size}
    \label{tab:chaincode-timings}
    \centering
    \begin{tabular}{|c|c|c|c|}
    \hline
    $\log N$ & \texttt{InitLedger} & \texttt{GetMetadata} & \texttt{PIRQuery} \\
    \hline
    13 & 165.24 & 6.16 & 12.53 \\
    14 & 187.03 & 8.31 & 18.17 \\
    15 & 307.87 & 5.94 & 40.36 \\
    \hline
    \end{tabular}
\end{table}

\begin{figure}[!h]
    \centering
    \includegraphics[width=\columnwidth]{figures/plots/chaincode_timings_bw.pdf}
    \caption{Average chaincode execution time by function and ring size. Each bar represents the mean execution time over multiple epochs.}
    \label{fig:chaincode-timings}
\end{figure}

\noindent \textit{Remark (Submittion paths reminder).} 
Transactions that modify world state (e.g., \textsf{InitLedger}) 
are issued via the \textsf{submit} path and commit through Raft consensus, 
while read-only operations (\textsf{GetMetadata}, \textsf{PIRQuery}) 
use the \textsf{evaluate} path, which bypasses ordering and block creation. 

\subsection{DISCUSSION}

The results, summarized in Table~\ref{tab:crypto-times}, highlight a nearly linear growth trend in total latency with respect to $\log N$.

\begin{table}[!h]
    \caption{Execution Time of Cryptographic Operations (ms)}
    \label{tab:crypto-times}
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    $\log N$ & KeyGen & Enc & Eval & Dec \\
    \hline
    13 & 27.7 & 11.7 & 16.9 & 5.1 \\
    14 & 42.7 & 27.7 & 30.7 & 11.9 \\
    15 & 55.0 & 49.8 & 64.8 & 15.6 \\
    \hline
    \end{tabular}
\end{table}

\noindent The \emph{KeyGen} dominates at small scales due to keypair initialization and parameter validation in \texttt{Lattigo}. 
\emph{Enc} and \emph{Eval} exhibit moderate scaling with ring size, reflecting the $O(N\log N)$ cost of NTT-based polynomial arithmetic. 
\emph{Dec} remains lightweight, averaging under 16~ms even for $N=2^{15}$, confirming that decryption and slot extraction overheads are negligible. 
Overall, end-to-end query latency remains below 200~ms for all configurations, demonstrating that CPIR can be feasibly embedded within Fabric’s \textsf{evaluate} transaction path.

Table~\ref{tab:artifact-sizes} lists the corresponding averages for each $\log N$ configuration.

\begin{table}[!h]
    \caption{Size of Main Cryptographic Artifacts (KB)}
    \label{tab:artifact-sizes}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    $\log N$ & pk & sk & $ct_q$ & $ct_r$ & $m_{\mathrm{DB}}$ & Metadata \\
    \hline
    13 & 256.1 & 128.0 & 128.3 & 128.3 & 64.3 & 0.08 \\
    14 & 512.1 & 256.0 & 256.3 & 256.3 & 128.3 & 0.08 \\
    15 & 1024.1 & 512.0 & 512.3 & 512.3 & 256.3 & 0.08 \\
    \hline
    \end{tabular}
\end{table}
As expected, artifact sizes scale linearly with the ring dimension $N = 2^{\log N}$.
Public and secret keys exhibit a 2$\times$ growth per level, consistent with BGV’s
key structure. Ciphertexts ($ct_q$, $ct_r$) approximately double in size with each
increment in $\log N$, while the plaintext polynomial $m_{\mathrm{DB}}$ occupies
roughly half of a ciphertext’s footprint. Metadata remains negligible in size
($< 0.1$~KB). Base64 serialization introduces a $\sim$33\% wire overhead but does not
affect the underlying cryptographic representation.

\texttt{InitLedger} exhibits the largest execution time, reflecting the cost of initializing and inserting a large batch of encoded CTI records into the ledger world state. 
\texttt{PIRQuery} remains sublinear with respect to initialization, reflecting the cost of single-query PIR evaluation, which depends on homomorphic multiplication and slot decoding for the given ring dimension. 
\texttt{GetMetadata}, in contrast, executes quickly ($<10$\,ms on average) since it only retrieves pre-initialized ledger parameters without heavy computation.
As expected, increasing $\log N$ leads to a monotonic rise in execution time for the PIR-related operations, with the most pronounced growth between $\log N=14$ and $\log N=15$.

Across all configurations, utilization remains above $98\%$, indicating near-optimal packing under the feasibility constraints of Fig.~\ref{fig:exp-matrix}.
Slight underutilization (e.g., $u\approx0.984$) arises from rounding of slot windows to the nearest discrete size in $\mathcal{S}={64,128,224,256,384,512}$, ensuring consistent record alignment and deterministic indexing.


\section{CONCLUSION}
The conclusion goes here.

\section*{APPENDIX}
Appendixes, if needed, appear before the acknowledgment.


\section*{ACKNOWLEDGMENT}
The preferred spelling of the word ``acknowledgment'' in
American English is without an ``e'' after the ``g.'' Use the
singular heading even if you have many acknowledgments.
Avoid expressions such as ``One of us (S.B.A.) would like
to thank . . . .'' Instead, write ``F. A. Author thanks . . . .'' In
most cases, sponsor and financial support acknowledgments
are placed in the unnumbered footnote on the first page, not
here.

%\section*{REFERENCES}

\bibliographystyle{IEEEtran}
\bibliography{bibliography}


\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{figures/authors/author1.png}}]
{FIRST A. AUTHOR}~(Fellow, IEEE)~and all authors may include biographies.
Biographies are often not included in conference-related papers. This author
is an IEEE Fellow. The first paragraph may contain a place and/or date of
birth (list place, then date). Next, the author's educational background is
listed. The degrees should be listed with type of degree in what field,
which institution, city, state, and country, and year the degree was earned.
The author's major field of study should be lower-cased.

The second paragraph uses the pronoun of the person (he or she) and not the
author's last name. It lists military and work experience, including summer
and fellowship jobs. Job titles are capitalized. The current job must have a
location; previous positions may be listed without one. Information
concerning previous publications may be included. Try not to list more than
three books or published articles. The format for listing publishers of a
book within the biography is: title of book (publisher name, year) similar
to a reference. Current and previous research interests end the paragraph.

The third paragraph begins with the author's title and last name
(e.g., Dr.\ Smith, Prof.\ Jones, Mr.\ Kajor, Ms.\ Hunter). List any memberships in
professional societies other than the IEEE. Finally, list any awards and
work for IEEE committees and publications. If a photograph is provided, it
should be of good quality, and professional-looking.
\end{IEEEbiography}


\begin{IEEEbiographynophoto}
{SECOND B. AUTHOR,} photograph and biography not available at the time
of publication.
\end{IEEEbiographynophoto}


\begin{IEEEbiographynophoto}
{THIRD C. AUTHOR JR.}~(Member, IEEE), photograph and biography not available
at the time of publication.
\end{IEEEbiographynophoto}

\vfill\pagebreak

\end{document}
