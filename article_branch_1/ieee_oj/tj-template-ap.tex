\documentclass{ieeetj}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx,color}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
%\hypersetup{hidelinks=true}
\usepackage{algorithm,algorithmic}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\AtBeginDocument{\definecolor{tmlcncolor}{cmyk}{0.93,0.59,0.15,0.02}\definecolor{NavyBlue}{RGB}{0,86,125}}




\def\OJlogo{\vspace{-4pt}$<$Society logo(s) and publication title will appear here.$>$}
\def\seclogo{\vspace{10pt}$<$Society logo(s) and publication title will appear here.$>$}

\def\authorrefmark#1{\ensuremath{^{\textbf{#1}}}}

\begin{document}
\receiveddate{XX Month, XXXX}
\reviseddate{XX Month, XXXX}
\accepteddate{XX Month, XXXX}
\publisheddate{XX Month, XXXX}
\currentdate{XX Month, XXXX}
\doiinfo{XXXX.2022.1234567}

\markboth{}{Author {et al.}}

\title{Blind Chaincode: Enabling Computational Private Information Retrieval for Query Privacy in Hyperledger Fabric}


\author{First A. Author\authorrefmark{1}, Fellow, IEEE, Second B. Author\authorrefmark{2},\\ and Third C. Author Jr.\authorrefmark{3}, Member, IEEE}
\affil{National Institute of Standards and Technology, Boulder, CO 80305 USA}
\affil{Department of Physics, Colorado State University, Fort Collins, CO 80523 USA}
\affil{Electrical Engineering Department, University of Colorado, Boulder, CO 80309 USA}
\corresp{Corresponding author: First A. Author (email: author@ boulder.nist.gov).}
\authornote{This paragraph of the first footnote will contain support information, including sponsor and financial support acknowledgment. For example, ``This work was supported in part by the U.S. Department of Commerce under Grant 123456.''}


\begin{abstract}
    Permissioned blockchains ensure integrity and auditability of shared data but expose query parameters to endorsing peers during read operations. 
    In Hyperledger Fabric, evaluate calls are executed by peers who observe function arguments and read-sets, creating privacy risks for organizations querying sensitive records. 
    We address this gap by presenting the first practical integration of Computational Private Information Retrieval (CPIR) into Fabric chaincode. 
    Our design encodes the ledger’s key–value table as a plaintext polynomial and allows clients to submit encrypted selection vectors, evaluated under the Brakerski--Gentry--Vaikuntanathan (BGV) homomorphic encryption scheme. 
    Peers return only encrypted responses, preventing index leakage while preserving normal Fabric endorsement and audit flows. 
    We prototype the system with the Lattigo library and benchmark client-side encryption/decryption, peer-side evaluation, ciphertext size, and end-to-end query latency. 
    Results show that single-query latencies remain practical for typical Fabric deployments, while eliminating the privacy leakage of baseline \texttt{GetState} operations. 
    This work demonstrates the feasibility of embedding CPIR directly into permissioned blockchains and provides a foundation for future enhancements such as post-quantum schemes, zero-knowledge proofs, and sublinear retrieval.
\end{abstract}
    

\begin{IEEEkeywords}
    Private Information Retrieval (PIR), Homomorphic Encryption, Hyperledger Fabric, Permissioned Blockchains, Query Privacy.
\end{IEEEkeywords}
    
    

%\IEEEspecialpapernotice{(Invited Paper)}

\maketitle

\section{INTRODUCTION}\label{sec:introduction}

\subsection{MOTIVATION AND CONTRIBUTION}

Permissioned blockchains such as Hyperledger Fabric are widely adopted for tamper-evident and auditable data management across consortiums. 
Their guarantees, however, primarily cover writes. 
In Fabric, the separation of \emph{evaluate} and \emph{submit} makes the read-privacy gap explicit: an evaluate call is a read-only proposal sent to endorsing peers, which execute the chaincode and return results without committing to the ledger. 
Crucially, these peers still observe all function arguments and read-sets. 
Thus, in multi-organization settings, the dominant privacy risk arises not from the immutable ledger, but from endorsing peers who can log or infer sensitive query information.

Private Information Retrieval (PIR)~\cite{ref16_Chor1998Private} addresses this challenge by enabling a client to retrieve an item from a database without revealing which item was requested. 
For a database $D = \{d_0,\dots,d_{n-1}\}$, the client forms a one-hot selection vector $\hat{v}_i$ with a single ``1'' at index $i$. 
By encrypting $\hat{v}_i$ into $c_q = \text{Enc}_{pk}(\hat{v}_i)$ and sending it to the server, the server computes an encrypted response 
$c_r = c_q \cdot D = \text{Enc}_{pk}(d_i)$, 
which decrypts to $d_i$ under the client’s secret key. 
This construction hides the queried index from the server. 
When integrated with Fabric chaincode, PIR prevents endorsing peers from linking queries to specific records, while preserving blockchain auditability for writes.

Figure~\ref{fig1} illustrates this contrast. 
A baseline query call \textit{PublicQueryWithAudit("record012")} explicitly reveals the queried key in the audit log visible to endorsing peers. 
In contrast, our \textit{PIRQueryWithAudit(encQueryB64)} logs only an opaque Base64-encoded selector, preventing the audit trail or the read-set from exposing query intent.

\begin{figure}[!t]
    \centerline{\includegraphics[width=\columnwidth]{figures/diagrams/0_pir.png}}
    \caption{What endorsing peers ``see'' in audit records. 
    Left: baseline \textit{PublicQueryWithAudit} exposes the queried key (\textit{record012}). 
    Right: CPIR-based \textit{PIRQueryWithAudit} exposes only an opaque encrypted selector (\textit{EncQueryB64}), hiding the queried index.\label{fig1}}    
\end{figure}

The main contributions of this work are:
\begin{enumerate}
    \item \textbf{BGV-based CPIR as Fabric chaincode.} We present, to the best of our knowledge, the first fully on-chain implementation of Computational PIR (CPIR) based on the BGV scheme, integrated directly into Hyperledger Fabric chaincode.
    \item \textbf{Evaluate-phase privacy demonstration.} We provide a side-by-side analysis of baseline vs. CPIR queries, showing how endorsing peers’ visibility is reduced to opaque ciphertexts while preserving Fabric’s normal endorsement and audit mechanisms.
    \item \textbf{Prototype and benchmarks.} We implement a working system with the Lattigo library and measure client encryption/decryption, peer evaluation, ciphertext size, and end-to-end query latency, demonstrating practical performance for consortium deployments.
    \item \textbf{Open-Source Release.} To encourage reproducibility and use by other researchers, we open-source the complete CPIR-on-Blockchain system, including chaincode, client, and experimental setup. The repository is available at: \url{https://github.com/artias13/2_2_HLF_CPIR}.
\end{enumerate}

\subsection{LITERATURE REVIEW}

Privacy in permissioned blockchains has been studied from several angles, but query privacy remains underexplored. 

\textbf{Blockchain Privacy Mechanisms.} 
Early efforts have emphasized access control and anonymity. 
Token-based authentication schemes~\cite{huff2021} and access-control contracts~\cite{allouche2020} prevent unauthorized reads or hide participant identities. 
Differential-sharing frameworks~\cite{dunnett2019} allow producers to regulate how much content is revealed. 
While effective at controlling \emph{who} sees data, these mechanisms do not conceal \emph{which} records are queried. 
Queries themselves remain visible to endorsing peers.

\textbf{PIR and FHE Applications.}
A line of work has applied Private Information Retrieval (PIR) or Fully Homomorphic Encryption (FHE) to protect data access. 
Tan et al.~\cite{tan2019} use CPIR to hide vehicular location queries. 
Chakraborty et al.~\cite{chakraborty2020} propose BRON, combining PIR with zero-knowledge proofs for human-resource data. 
Mazmudar et al.~\cite{mazmudar2021} integrate PIR with IPFS for private queries in distributed file sharing, while Hameed et al.~\cite{hameed2022} present DEBPIR, embedding an Oblivious Transfer–based PIR into Fabric smart contracts. 
These works demonstrate the feasibility of PIR in distributed settings but often rely on off-chain servers or specialized cryptographic protocols.

\textbf{On-Chain CPIR Gap.}
Existing solutions for Fabric focus on access restriction (channels, PDC) or enclave-based confidentiality (FPC). 
Recent PIR-based proposals either target off-chain databases or prototype OT-based protocols. 
To our knowledge, no prior system has directly integrated a lattice-based CPIR scheme into Fabric chaincode. 
Our work closes this gap by embedding a BGV-based PIR workflow directly in Fabric’s evaluate path, ensuring that endorsing peers cannot infer queried indices while preserving normal endorsement and auditability.

\subsection{ORGANIZATION}

The remainder of this paper is organized as follows: Section~II surveys related work on PIR and blockchain privacy. Section~III presents the system model and threat assumptions. Section~IV details the design and implementation of CPIR in Fabric. Section~V evaluates performance. Section~VI discusses limitations and future directions, and Section~VII concludes the paper.

\section{PRELIMINARIES}\label{sec:preliminaries}

\subsection{TECHNOLOGY BACKGROUND}

\emph{a) Fabric Native Privacy Techniques:}
Hyperledger Fabric separates roles among endorsing peers, committing peers, and the ordering service. 
Endorsing peers execute chaincode proposals and therefore observe function arguments, logs, and read-sets, making their administrators the natural adversaries for read privacy. 
Protecting reads in Fabric thus requires hiding query intent from endorsers.

Fabric already offers several native privacy mechanisms, each addressing a different dimension of confidentiality:
\begin{itemize}
    \item \emph{Separate Channels.} Multi-channel partitioning isolates ledgers across subgroups of organizations, limiting which participants observe which data. 
    However, channel separation controls \emph{who} sees a ledger, not \emph{what} is accessed inside that ledger. 
    Query intent remains visible to all endorsers of a channel.
    
    \item \emph{Private Data Collections (PDC).} PDCs restrict which organizations store and access private key–value pairs. 
    The shared ledger records only hashes, while members of the collection hold plaintext. 
    PDCs provide access control but still expose function arguments to endorsers inside the collection, leaving query patterns observable.
    
    \item \emph{Fabric Private Chaincode (FPC).} FPC executes chaincode within Intel SGX enclaves. 
    Arguments and state are protected even from peer operators, but this requires Trusted Execution Environments (TEEs) and attestation, introducing additional hardware and trust assumptions.
\end{itemize}

In summary, Fabric’s native privacy tools govern data visibility and execution confidentiality. 
They are orthogonal to Private Information Retrieval (PIR): PDC and FPC restrict who can see data, while PIR hides what data is queried.


\emph{b) Private Information Retrieval Basics:}
PIR protocols enable a client to retrieve a record without revealing which record was requested. 
They fall into two categories:

\emph{Information-Theoretic PIR (IT-PIR).} Provides unconditional privacy by distributing the database across multiple non-colluding servers. 
A client queries subsets of servers such that no single server learns the selection index.

\emph{Computational PIR (CPIR).} Achieves privacy with a single server, relying on hardness assumptions and homomorphic encryption. 
For a database $D=\{d_0,\dots,d_{n-1}\}$ and a one-hot selection vector $\hat{v}_i$, the client computes 
\[
c_q = \text{Enc}_{pk}(\hat{v}_i), \qquad c_r = c_q \cdot D = \text{Enc}_{pk}(d_i).
\]
The server returns $c_r$, which the client decrypts as $d_i = \text{Dec}_{sk}(c_r)$. 
Thus the queried index $i$ remains hidden from the server.

CPIR avoids the need for multiple servers, making it attractive in blockchain settings where peers cannot be assumed non-colluding.
%\noindent 

\emph{c) BGV Homomorphic Encryption:}
Our construction relies on the Brakerski–Gentry–Vaikuntanathan (BGV) scheme, a lattice-based homomorphic encryption system supporting both addition and multiplication over ciphertexts. 
BGV is defined over polynomial rings modulo a large ciphertext modulus and enables \emph{batching}, where multiple plaintext elements are packed into a single ciphertext. 
In our design, this batching is used to embed the ledger’s key–value table into a single polynomial $m_{\mathrm{DB}}$, allowing efficient evaluation of structured PIR queries inside chaincode and underpins the polynomial database representation used in our Fabric integration.

\subsection{Notation}
We summarize the main notation used throughout the paper in Table~\ref{tab:notation}.

\noindent\textit{Remark.} We write $ct_r = ct_q \cdot m_{\mathrm{DB}}$ to denote BGV ciphertext–plaintext multiplication with batching; concretely, this realizes
\[
\mathsf{Enc}_{pk}(\hat{v}_i)\ \cdot\ m_{\mathrm{DB}}\ =\ \mathsf{Enc}_{pk}(d_i).
\]

\begin{table}[!t]
    \caption{Notation}
    \label{tab:notation}
    \setlength{\tabcolsep}{3pt}
    \renewcommand{\arraystretch}{1.1}
        \begin{tabular}{|p{78pt}|p{170pt}|}
        \hline
        \textbf{Symbol} & \textbf{Description} \\
        \hline
        $\lambda$ & Security parameter \\
        \hline
        $n$ & Database size; index domain $[n]=\{0,\dots,n-1\}$ \\
        \hline
        $D=\{d_0,\dots,d_{n-1}\}$ & Database records (serialized bytes/words) \\
        \hline
        $m_{\mathrm{DB}}$ & Plaintext polynomial representation of $D$ (BGV batching) \\
        \hline
        $\hat{v}_i$ & One-hot selection vector for index $i$ (1 in one slot, 0 elsewhere) \\
        \hline
        $v_i$ & Windowed selector for index $i$ with $record_s$ contiguous ones (retrieves full record window) \\
        \hline
        $pk,\, sk$ & Public / secret keys (BGV) \\
        \hline
        $ct_q=\mathsf{Enc}_{pk}(v_i)$ & Encrypted query (ciphertext) \\
        \hline
        $ct_r=\mathsf{Eval}(ct_q, m_{\mathrm{DB}})$ & Encrypted response; $ct_r=\mathsf{Enc}_{pk}(d_i)$ \\
        \hline
        $d_i=\mathsf{Dec}_{sk}(ct_r)$ & Decrypted record $d_i$ retrieved by client \\
        \hline
        $\mathsf{KeyGen}(\lambda)\!\to\!(pk,sk)$ & Key generation \\
        \hline
        $\mathsf{Enc}_{pk}(\cdot)$, $\mathsf{Dec}_{sk}(\cdot)$ & Encrypt / Decrypt \\
        \hline
        $\mathsf{Eval}(\cdot)$ & Homomorphic evaluation (ct–pt multiply) \\
        \hline
        $N$ & Ring dimension ($N=2^{\log N}$) (BGV) \\
        \hline
        $q$ & Ciphertext modulus (BGV) \\
        \hline
        $t$ & Plaintext modulus (BGV) \\
        \hline
        $record_s$ & Slots allocated per record (slot window size) \\
        \hline
        $record_b$ & Base serialized size of a record in bytes \\
        \hline
        $record_{\mu,\log N}$ & Template-specific minimum record size at security level $\log N$ \\
        \hline
        $\mathcal{S}$ & Allowed discrete slot sizes (implementation policy) \\
        \hline
        ${c}=(c_0,\dots,c_{N-1})$ & Coefficient vector of the polynomial encoding (slots of $m_{\mathrm{DB}}$) \\
        \hline
        $|\cdot|$, $\mathrm{size}(\cdot)$ & Length in elements / size in bytes \\
        \hline
        $\mathcal{DO},\,\mathcal{DW},\,\mathcal{DR},\,\mathcal{GW}$ & Data Owner; Data Writer; Data Requester; Gateway \\
        \hline
        \textsf{evaluate}, \textsf{submit} & Fabric read / write transaction phases \\
        \hline
        $\mathcal{L}$ & Leakage considered (ciphertext size, protocol timing) \\
        \hline
        \end{tabular}
    \end{table}

\subsection{Cryptographic Primitives}
CPIR can be instantiated as a tuple of probabilistic polynomial-time algorithms:
\[
\Pi = (\mathsf{KeyGen}, \mathsf{Enc}, \mathsf{Eval}, \mathsf{Dec}),
\]
defined as follows:

\begin{itemize}
    \item $\mathsf{KeyGen}(\lambda) \rightarrow (pk, sk)$: On input the security parameter $\lambda$, output a public key $pk$ and a secret key $sk$.
    \item $\mathsf{Enc}_{pk}(\hat{v}_i) \rightarrow ct_q$: Given a one-hot selection vector $\hat{v}_i \in \{0,1\}^n$, produce an encrypted query ciphertext $ct_q$ under $pk$.
    \item $\mathsf{Eval}(ct_q, m_{\mathrm{DB}}) \rightarrow ct_r$: Given an encrypted query $ct_q$ and the plaintext database polynomial $m_{\mathrm{DB}}$, homomorphically evaluate the product to obtain an encrypted response $ct_r$.
    \item $\mathsf{Dec}_{sk}(ct_r) \rightarrow d_i$: Using the secret key $sk$, decrypt the response ciphertext $ct_r$ to recover the desired record $d_i$.
\end{itemize}

\noindent \textbf{Protocol objective.} 
Correctness requires that for all $i \in [n]$,
\[
\mathsf{Dec}_{sk}\!\left(\mathsf{Eval}\!\left(\mathsf{Enc}_{pk}(\hat{v}_i), m_{\mathrm{DB}}\right)\right) = d_i.
\]

\section{Proposed System}

\subsection{System Model}
We introduce a blockchain-based query privacy system designed for permissioned ledgers. 
The system enables clients to privately retrieve from the ledger while endorsing peers can evaluate read-only queries over encrypted inputs without learning which record was accessed.  
The novelty of our approach lies in the integration of computational Private Information Retrieval (CPIR) into Hyperledger Fabric chaincode using the Brakerski--Gentry--Vaikuntanathan (BGV) homomorphic encryption scheme. 
This approach ensures that clients remain the sole holders of decryption keys, while peers perform only black-box computations, thereby enhancing overall privacy without requiring trusted hardware or protocol modifications.

\noindent Our system is composed of the following entities:

\begin{itemize}
    \item \textbf{Data Owner ($\mathcal{DO}$):} Endorsing peers that hold the current plaintext polynomial $m_{\mathrm{DB}}$ in world state and execute PIR during \textsf{evaluate}. $\mathcal{DO}$ is honest-but-curious.
    \item \textbf{Data Writer ($\mathcal{DW}$):} A client organization that provisions or refreshes the database. $\mathcal{DW}$ invokes \textsf{submit} to initialize the ledger (e.g., set $n$ and template bounds). Chaincode computes $record_s$, packs $D=\{d_0,\dots,d_{n-1}\}$, encodes it into $m_{\mathrm{DB}}$, and persists it.
    \item \textbf{Data Requester ($\mathcal{DR}$):} A client that privately retrieves a record. $\mathcal{DR}$ runs $\mathsf{KeyGen}(\lambda)\!\to\!(pk,sk)$, forms $ct_q=\mathsf{Enc}_{pk}(v_i)$, calls \textsf{evaluate} \textsf{PIRQuery}, and later decrypts $ct_r$.
    \item \textbf{Gateway ($\mathcal{GW}$):} The Fabric client/chaincode interface used by $\mathcal{DW}$ and $\mathcal{DR}$ to invoke \textsf{InitLedger}, \textsf{GetMetadata}, and \textsf{PIRQuery}. It follows standard Fabric semantics; no extra trust is assumed.
\end{itemize}

\noindent\textit{Remark.} In Fabric, the "ledger" comprises the blockchain log and the world state. Our CPIR operates on the world state: $m_{\mathrm{DB}}$ encodes the latest key--value snapshot, not the historical transaction logs.

\subsection{Security Assumptions and Threat Model}

Our design follows the standard \emph{honest-but-curious} adversarial model. 
We explicitly consider the following assumptions and threats:

\begin{itemize}
    \item \textbf{Endorsing peers ($\mathcal{DO}$).} Execute chaincode correctly but may try to infer the queried index from \textsf{evaluate} inputs or logs. They see $ct_q$, metadata, and $m_{\mathrm{DB}}$.
    \item \textbf{Data Writer ($\mathcal{DW}$).} Issues initialization writes via \textsf{submit}. $\mathcal{DW}$ is not trusted with decryption keys and learns nothing about $\mathcal{DR}$’s queries. We assume $\mathcal{DW}$ follows the write protocol but is not relied upon for privacy.
    \item \textbf{External observers.} May eavesdrop on client–peer traffic. Without $sk$, $ct_q$ and $ct_r$ reveal nothing under BGV assumptions.
    \item \textbf{Out of scope.} Traffic analysis and timing side-channels; the only permitted leakage is $\mathcal{L}$ (ciphertext size and protocol timing).
\end{itemize}

\noindent \textbf{Security objective.} 
For any $i\in[n]$, neither $\mathcal{DO}$ nor external observers can distinguish which $d_i$ is requested from $ct_q$ and $ct_r$.
The only permissible leakage is ciphertext size and protocol timing, denoted collectively as $\mathcal{L}$.


\subsection{System Overview}

The proposed system integrates computational Private Information Retrieval (CPIR) directly into Hyperledger Fabric chaincode. 
Its purpose is to ensure that query indices remain hidden from endorsing peers while preserving Fabric’s endorsement and audit workflow. 
At a high level, the workflow consists of four stages, illustrated in Fig.~\ref{fig:system-overview}.

\begin{enumerate}
    \item \textbf{Ledger initialization.}
    $\mathcal{DW}$ invokes \textsf{InitLedger} via $\mathcal{GW}$ using \textsf{submit}. Chaincode derives $record_s$ from $record_b$, packs $D$ into $\mathbf{c}=(c_0,\dots,c_{N-1})$, encodes $m_{\mathrm{DB}}$, and stores $m_{\mathrm{DB}}$ and metadata in world state held by $\mathcal{DO}$.
    \item \textbf{Metadata discovery.}
    $\mathcal{DR}$ calls \textsf{GetMetadata} via \textsf{evaluate} to obtain $n$, $record_s$, and BGV parameters needed to form a valid query.
    \item \textbf{Private retrieval.}
    $\mathcal{DR}$ constructs $ct_q=\mathsf{Enc}_{pk}(v_i)$ and invokes \textsf{PIRQuery} via \textsf{evaluate}. $\mathcal{DO}$ computes $ct_r=\mathsf{Eval}(ct_q,m_{\mathrm{DB}})$ and returns it.
    \item \textbf{Decryption.}
    $\mathcal{DR}$ decrypts $ct_r$ to recover $d_i=\mathsf{Dec}_{sk}(ct_r)$.
\end{enumerate}

\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{figures/diagrams/1_workflow.png}
    \caption{Workflow: $\mathcal{DW}$ initializes the world state by causing chaincode to encode $D$ into $m_{\mathrm{DB}}$ and persist it. $\mathcal{DR}$ later obtains metadata, submits $ct_q=\mathsf{Enc}_{pk}(v_i)$, endorsing peers ($\mathcal{DO}$) evaluate $ct_r=\mathsf{Eval}(ct_q,m_{\mathrm{DB}})$, and $\mathcal{DR}$ decrypts to $d_i$.}
    \label{fig:system-overview}
\end{figure}

\subsection{Encoding and Packing Strategy}

To enable PIR queries over structured ledger data, we must embed records into a plaintext polynomial $m_{\mathrm{DB}}$ suitable for BGV evaluation. 
Our prototype adopts a fixed-width packing strategy, illustrated in Fig.~\ref{fig:polynomial-construction}, which proceeds in four steps.

\begin{figure*}[!t]
    \centering
    \includegraphics[width=\textwidth]{figures/diagrams/2_polynomial_construction.png}
    \caption{$m_{\mathrm{DB}}$ construction from JSON to plaintext polynomial. 
    Each record is serialized to bytes, mapped into a fixed slot window $record_s$, and packed into a coefficient vector $c$. 
    The vector is then encoded as a BGV plaintext polynomial $m_{\mathrm{DB}}$, which is stored in the Fabric world state.}
    \label{fig:polynomial-construction}
\end{figure*}

\textbf{Step 1: Serialize to Byte Array.}
Each ledger record $d_i$ is serialized as a UTF-8 byte array. 
In our motivating use case of Cyber Threat Intelligence (CTI) sharing, JSON objects containing fields such as hash digests and threat levels are flattened into byte sequences. 
Every character is represented by its ASCII code in $[0,255]$. 
This ensures that arbitrary structured records can be embedded in the polynomial without loss of information.

\textbf{Step 2: Calculate Slot Window.} 
We determine the slot allocation per record as:
\[
record_s = \left\lceil \frac{record_b}{\textit{bytesPerSlot}} \right\rceil,
\]
where $record_b$ is the maximum serialized record length observed in bytes.  
In our prototype, each slot stores exactly one byte.  
For example, if the largest record is $126$ bytes, then $record_s = \lceil 126/1 \rceil = 126$, which rounds up to $128$ slots due to the discrete window policy.  
This guarantees uniform slot windows across all records, simplifying query construction at the cost of potential padding overhead.

\textbf{Step 3: Pack into Coefficient Vector.} 
Serialized byte arrays are inserted into disjoint slot windows of length $record_s$ within a coefficient vector 
$c = (c_0, c_1, \dots, c_{N-1})$,  
where $N = 2^{\log N}$ is the ring capacity of the BGV scheme. 
Padding zeros are added if a record is shorter than $record_s$.  
Thus each record $d_i$ occupies a contiguous slot interval that can be privately retrieved through PIR.

\textbf{Step 4: Encode into Polynomial.} 
Finally, the coefficient vector $d$ is encoded into a plaintext polynomial:
\[
m_{\mathrm{DB}}(X) = \sum_{j=0}^{N-1} c_j X^j \in R_t,
\]
where $R_t = \mathbb{Z}_t[X]/(X^N+1)$. 
This polynomial serves as the plaintext database representation stored in the Fabric world state. 
Endorsing peers operate over $m_{\mathrm{DB}}$ during PIR queries, while clients recover only the slots corresponding to their requested record.

\subsection{Packing Constraints}

Embedding records into the plaintext polynomial $m_{\mathrm{DB}}$ is feasible only for parameter triples 
$(\log N, n, record_s)$ that satisfy \emph{all} of the following constraints. 
These constraints form a hierarchical relationship: template requirements dominate discrete allocation, 
and both are ultimately bounded by ring capacity.

\textbf{Constraint 1: Ring capacity.}
The total number of occupied slots cannot exceed the ring size:
\[
n \cdot record_s \ \leq \ N.
\]
This represents the fundamental mathematical limit imposed by the cryptographic parameters. 
For example, with $\log N = 13$ ($N = 8192$) and $record_s = 224$, 
at most $\lfloor 8192/224 \rfloor = 36$ records can be packed.

\textbf{Constraint 2: Template-specific minima.}
Each security level ($\log N$) corresponds to a record template with mandatory fields 
that impose a minimum slot requirement $record_{\mu,\log N}$. Examples include:
\begin{itemize}
    \item \textbf{Mini records} ($\log N = 13$): MD5 hash + malware family + threat level $\;\;\Rightarrow\;\; record_{\mu,13} \approx 128$ bytes.
    \item \textbf{Mid records} ($\log N = 14$): MD5 + SHA-256 short + malware class + AV detects $\;\;\Rightarrow\;\; record_{\mu,14} \approx 224$ bytes.
    \item \textbf{Rich records} ($\log N = 15$): MD5 + full SHA-256 + all metadata $\;\;\Rightarrow\;\; record_{\mu,15} \approx 256$ bytes.
\end{itemize}

These minima arise from generator checks of the form:
\[
\begin{aligned}
    \textsf{Mini:}\quad & record_s \ \geq \ record_b + 32 + 15, \\
    \textsf{Mid:}\quad  & record_s \ \geq \ record_b + 32 + 16 + 15, \\
    \textsf{Rich:}\quad & record_s \ \geq \ record_b + 32 + 64 + 15,
\end{aligned}
\]
where $record_b \approx 113$--125 bytes denotes the base JSON structure 
and numeric terms represent mandatory hash fields and serialization overhead.

\textbf{Constraint 3: Discrete allocation policy.}
Operationally, we restrict the slot window $record_s$ to a discrete set for implementation simplicity:
\[
\mathcal{S} = \{64, 128, 224, 256, 384, 512\} \ \text{bytes}.
\]
This means that even if Constraints~1 and~2 are satisfied, 
the configuration is rejected unless $record_s \in \mathcal{S}$.

\noindent\textbf{Constraint hierarchy and feasibility.}
Feasibility of a configuration $(\log N,n,record_s)$ is defined by three predicates:
\begin{align*}
\mathsf{Cap}(N,s,n) &: n \cdot s \leq N \quad \text{(ring capacity)} \\
\mathsf{Min}(\log N,s) &: s \geq record_{\mu,\log N} \quad \text{(template minimum)} \\
\mathsf{Disc}(s) &: s \in \mathcal{S} \quad \text{(discrete allocation)} .
\end{align*}
where $s=record_s$ and $N=2^{\log N}$. A configuration is feasible iff:
\[
\mathsf{Cap}(N,s,n)\ \wedge\ \mathsf{Min}(\log N,s)\ \wedge\ \mathsf{Disc}(s).
\]

\noindent\textbf{Examples.} The interaction of these predicates is illustrated in Fig.~\ref{fig:exp-matrix}.
\begin{itemize}
    \item $\log N=13$ (Mini): requires $record_s \geq record_{\mu,13} \approx 128$, so $128$ is the smallest valid window. Capacity then gives $n \leq \lfloor 8192/128 \rfloor = 64$.
    \item $\log N=14$ (Mid): requires $record_s \geq record_{\mu,14} \approx 224$, so valid choices are $224,256,\dots$. With $N=16384$, the capacity bound is $n \leq \lfloor 16384/224 \rfloor = 73$.
    \item $\log N=15$ (Rich): requires $record_s \geq record_{\mu,15} \approx 256$, so smaller windows (64,128,224) are invalid. With $N=32768$, the bound is $n \leq \lfloor 32768/256 \rfloor = 128$.
\end{itemize}

\begin{figure}[!b]
    \centering
    \includegraphics[width=\columnwidth]{figures/diagrams/3_feasible_configs.png}
    \caption{Feasible configurations under the joint constraints $\mathsf{Cap}$, $\mathsf{Min}$, and $\mathsf{Disc}$. Dashed curves show ring-capacity limits for $\log N \in \{13,14,15\}$, vertical lines mark template-driven minima $record_{\mu,\log N}$, and x-axis ticks correspond to discrete slot sizes $\mathcal{S}$. Circles indicate feasible triples $(\log N,record_s,n)$.}
    \label{fig:exp-matrix}
\end{figure}

\noindent\textbf{Implications.} Higher $\log N$ enlarges ring capacity and thus potential $n$, but also forces larger $record_s$ through richer record templates. The discrete allocation policy $\mathcal{S}$ simplifies implementation while bounding overhead. Practically, feasible points emerge only where template requirements align with ring capacity, guiding parameter selection in system deployment.

\subsection{Multi-Channel Architecture}

The packing strategy and feasibility constraints highlight an important observation: 
no single homomorphic parameter set can efficiently support the full diversity of Cyber Threat Intelligence (CTI) record formats. 
Compact records fit comfortably under smaller rings, while full JSON objects with long cryptographic hashes exceed the slot budget of these configurations. 
To balance scalability and expressiveness, we design a \emph{multi-channel architecture} in Hyperledger Fabric, 
where each channel is provisioned with a distinct BGV parameter set and record template.

\textbf{Channel Mini} ($\log N=13$).
Supports compact CTI records (e.g., MD5, malware family, threat level) with maximum scalability and lowest query latency. 
For example, with $N=8192$ slots, the system accommodates up to 128 records when $\max_i |d_i| \leq 64$ bytes, 
and 16 records when $\max_i |d_i| \leq 512$ bytes.

\textbf{Channel Mid} ($\log N=14$).
Targets medium-sized records that include MD5 and truncated SHA-256 fields alongside classification metadata. 
With $N=16384$ slots, the system supports up to 256 records at $\leq 64$ bytes or 32 records at $\leq 512$ bytes.

\textbf{Channel Rich} ($\log N=15$).
Handles the most detailed records, including full-length hashes and multiple metadata fields. 
Here, $N=32768$ slots allow up to 512 records at $\leq 64$ bytes or 64 records at $\leq 512$ bytes.

\begin{figure*}[!t]
    \centering
    \includegraphics[width=\textwidth]{figures/diagrams/4_multi_channel_arc.png}
    \caption{Multi-channel CPIR architecture. 
    Each channel instantiates a separate CPIR chaincode and maintains its own $m_{\mathrm{DB}}$ polynomial, 
    parameterized by $\log N$. This allows compact, mid-size, and rich CTI records to coexist under the same Fabric network.}
    \label{fig:multi-channel}
\end{figure*}

\textbf{Channel semantics.}
Each channel maintains its own plaintext polynomial database $m_{\mathrm{DB}}$ encoded according to Fig.~\ref{fig:polynomial-construction}. 
Fabric’s world state thus contains both:
\begin{enumerate}
    \item The \emph{normal view}: JSON-formatted CTI records for auditability and integration with non-PIR chaincode.
    \item The \emph{polynomial view}: $m_{\mathrm{DB}}$, used exclusively by the PIR chaincode for homomorphic evaluation.
\end{enumerate}
This dual representation ensures that endorsing peers can still serve conventional read requests 
(e.g., \textsf{PublicQueryALL}) while PIR queries operate only over the encrypted polynomial interface.




\section{CONCLUSION}
The conclusion goes here.

\section*{APPENDIX}
Appendixes, if needed, appear before the acknowledgment.


\section*{ACKNOWLEDGMENT}
The preferred spelling of the word ``acknowledgment'' in
American English is without an ``e'' after the ``g.'' Use the
singular heading even if you have many acknowledgments.
Avoid expressions such as ``One of us (S.B.A.) would like
to thank . . . .'' Instead, write ``F. A. Author thanks . . . .'' In
most cases, sponsor and financial support acknowledgments
are placed in the unnumbered footnote on the first page, not
here.

%\section*{REFERENCES}

\bibliographystyle{IEEEtran}
\bibliography{bibliography}


\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{figures/authors/author1.png}}]
{FIRST A. AUTHOR}~(Fellow, IEEE)~and all authors may include biographies.
Biographies are often not included in conference-related papers. This author
is an IEEE Fellow. The first paragraph may contain a place and/or date of
birth (list place, then date). Next, the author's educational background is
listed. The degrees should be listed with type of degree in what field,
which institution, city, state, and country, and year the degree was earned.
The author's major field of study should be lower-cased.

The second paragraph uses the pronoun of the person (he or she) and not the
author's last name. It lists military and work experience, including summer
and fellowship jobs. Job titles are capitalized. The current job must have a
location; previous positions may be listed without one. Information
concerning previous publications may be included. Try not to list more than
three books or published articles. The format for listing publishers of a
book within the biography is: title of book (publisher name, year) similar
to a reference. Current and previous research interests end the paragraph.

The third paragraph begins with the author's title and last name
(e.g., Dr.\ Smith, Prof.\ Jones, Mr.\ Kajor, Ms.\ Hunter). List any memberships in
professional societies other than the IEEE. Finally, list any awards and
work for IEEE committees and publications. If a photograph is provided, it
should be of good quality, and professional-looking.
\end{IEEEbiography}


\begin{IEEEbiographynophoto}
{SECOND B. AUTHOR,} photograph and biography not available at the time
of publication.
\end{IEEEbiographynophoto}


\begin{IEEEbiographynophoto}
{THIRD C. AUTHOR JR.}~(Member, IEEE), photograph and biography not available
at the time of publication.
\end{IEEEbiographynophoto}

\vfill\pagebreak

\end{document}
